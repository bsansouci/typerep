(**
   Place holder for common Variants and Fields interface
*)

module M (X : sig
  type 'a t
end) = struct


  (* The functions prefixed by [internal]as well as the module suffixed by [_internal] are
     used by the code generated by the camlp4 extension [with typerep] as well as some
     internals of the typerep library. Do not consider using these somewhere else.  They
     should ideally not be exported outside the typerep library, but the generated code
     needs somehow to access this, even outside. *)

  module Tag_internal = struct
    type ('variant, 'args) create = Args of ('args -> 'variant) | Const of 'variant
    type ('variant, 'args) t = {
      label : string;
      rep : 'args X.t;
      arity : int;
      index : int;
      ocaml_repr : int;
      tyid : 'args Type_name.t;
      create : ('variant, 'args) create;
    }
  end

  module Tag : sig
    type ('variant, 'args) create = Args of ('args -> 'variant) | Const of 'variant
    type ('variant, 'args) t

    val label : (_, _) t -> string
    val arity : (_, _) t -> int
    val index : (_, _) t -> int
    val ocaml_repr : (_, _) t -> int
    val create : ('variant, 'args) t -> ('variant, 'args) create
    val tyid : (_, 'args) t -> 'args Type_name.t
    val traverse : (_, 'args) t -> 'args X.t

    val internal_use_only : ('a, 'b) Tag_internal.t -> ('a, 'b) t
  end = struct
    include Tag_internal
    let label t = t.label
    let arity t = t.arity
    let index t = t.index
    let ocaml_repr t = t.ocaml_repr
    let create t = t.create
    let tyid t = t.tyid
    let traverse t = t.rep

    let internal_use_only t = t
  end

  module Variant_internal = struct
    type _ tag = Tag : ('variant, 'a) Tag.t -> 'variant tag
    type _ value = Value : ('variant, 'a) Tag.t * 'a -> 'variant value
    type 'a t = {
      typename : 'a Type_name.t;
      tags : 'a tag array;
      polymorphic : bool;
      value : 'a -> 'a value;
    }
  end

  module Variant : sig
    type _ tag = Tag : ('variant, 'a) Tag.t -> 'variant tag
    type _ value = Value : ('variant, 'a) Tag.t * 'a -> 'variant value
    type 'a t

    val typename_of_t : 'a t -> 'a Type_name.t
    val length : 'a t -> int
    val tag : 'a t -> int -> 'a tag
    val is_polymorphic : _ t -> bool
    val value : 'a t -> 'a -> 'a value

    val fold : 'a t -> init:'acc -> f:('acc -> 'a tag -> 'acc) -> 'acc

    val internal_use_only : 'a Variant_internal.t -> 'a t
  end = struct
    include Variant_internal
    let typename_of_t t = t.typename
    let length t = Array.length t.tags
    let tag t index = t.tags.(index)
    let is_polymorphic t = t.polymorphic
    let value t = t.value

    let fold t ~init ~f = Array.fold_left f init t.tags

    let internal_use_only t = t
  end

  module Field_internal = struct
    type ('record, 'field) t = {
      label : string;
      rep : 'field X.t;
      index : int;
      tyid : 'field Type_name.t;
      get : ('record -> 'field);
      (* set : ('record -> 'field -> unit) option; (\* mutable field *\) *)
    }
  end

  module Field : sig
    type ('record, 'field) t

    val label : (_, _) t -> string
    val index : (_, _) t -> int
    val get : ('record, 'field) t -> 'record -> 'field
    val tyid : (_, 'field) t -> 'field Type_name.t
    val traverse : (_, 'field) t -> 'field X.t

    val internal_use_only : ('a, 'b) Field_internal.t -> ('a, 'b) t
  end = struct
    include Field_internal
    let label t = t.label
    let index t = t.index
    let get t = t.get
    let tyid t = t.tyid
    let traverse t = t.rep

    let internal_use_only t = t
  end

  module Record_internal = struct
    type _ field = Field : ('record, 'a) Field.t -> 'record field
    type 'record fields = { get : 'field. ('record, 'field) Field.t -> 'field }
    type 'a t = {
      typename : 'a Type_name.t;
      fields : 'a field array;
      has_double_array_tag : bool;
      create : 'a fields -> 'a;
    }
  end

  module Record : sig
    type _ field = Field : ('record, 'a) Field.t -> 'record field
    type 'record fields = { get : 'field. ('record, 'field) Field.t -> 'field }
    type 'a t

    val typename_of_t : 'a t -> 'a Type_name.t
    val length : 'a t -> int
    val field : 'a t -> int -> 'a field
    val has_double_array_tag : _ t -> bool
    val create : 'a t -> 'a fields -> 'a

    val fold : 'a t -> init:'acc -> f:('acc -> 'a field -> 'acc) -> 'acc

    val internal_use_only : 'a Record_internal.t -> 'a t
  end = struct
    include Record_internal
    let typename_of_t t = t.typename
    let length t = Array.length t.fields
    let field t index = t.fields.(index)
    let has_double_array_tag t = t.has_double_array_tag
    let create t = t.create
    let fold t ~init ~f = Array.fold_left f init t.fields

    let internal_use_only t = t
  end
end

module type S = sig
  type 'a t
  include (module type of M (struct type 'a rep = 'a t type 'a t = 'a rep end))
end

